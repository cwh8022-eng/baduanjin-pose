<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>八段錦辨識（shim 修復版）</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;background:#f0f4f8;text-align:center;padding:20px}
    h1{color:#2c3e50;margin:6px 0 12px}
    #ver{color:#555;margin:4px 0 12px}
    #msg{margin-top:10px;font-weight:700;color:#c0392b;white-space:pre-line}
    button{margin:10px;padding:10px 20px;font-size:16px;border:0;border-radius:6px;background:#2980b9;color:#fff;cursor:pointer}
    canvas{display:block;margin:16px auto;border:2px solid #2c3e50;border-radius:10px}
    #labels div{font-size:16px;margin-top:6px}
  </style>

  <!-- 1) 固定載 TFJS 3.11.0 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>

  <!-- 2) shim 強化：確保 fromPixels 可用 -->
  <script>
    (function(){
      if (!window.tf) return console.error('[shim] tf not found');

      var hasOld = typeof tf.fromPixels === 'function';
      var hasNew = tf.browser && typeof tf.browser.fromPixels === 'function';

      if (!hasOld && hasNew) {
        var fp = tf.browser.fromPixels.bind(tf.browser);
        try {
          Object.defineProperty(tf, 'fromPixels', {
            value: fp, writable: false, configurable: false, enumerable: false
          });
        } catch(e) {
          tf.fromPixels = fp;
        }
        console.log('[shim] fromPixels installed & hardened');
      } else {
        console.log('[shim] not needed. hasOld=', hasOld, 'hasNew=', hasNew);
      }

      // 監控是否被覆蓋
      var orig = tf.fromPixels;
      setInterval(function(){
        if (typeof tf.fromPixels !== 'function' || tf.fromPixels !== orig) {
          console.warn('[shim] tf.fromPixels 被覆蓋，正在還原…');
          try {
            Object.defineProperty(tf, 'fromPixels', {
              value: orig, writable: false, configurable: false
            });
          } catch(e) {
            tf.fromPixels = orig;
          }
        }
      }, 500);
    })();
  </script>

  <!-- 3) 載入 Teachable Machine Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
</head>
<body>
  <h1>八段錦辨識（shim 修復版）</h1>
  <div id="ver">初始化中…</div>

  <button id="btnCheck">① 相機自檢</button>
  <button id="btnStart">② 載入模型並開始</button>

  <div id="msg"></div>
  <canvas id="canvas" width="400" height="400" style="display:none"></canvas>
  <div id="labels"></div>

<script>
(function(){
  const verEl = document.getElementById('ver');
  const msgEl = document.getElementById('msg');
  const btnCheck = document.getElementById('btnCheck');
  const btnStart = document.getElementById('btnStart');

  // 顯示環境與版本
  verEl.textContent =
    `SecureContext=${window.isSecureContext} | tfjs=${(tf&&tf.version&&tf.version.tfjs)||'未載'} | has fromPixels=${typeof tf.fromPixels==='function'}`;

  // 本地模型路徑
  const modelURL    = './model.json';
  const metadataURL = './metadata.json';

  let model, webcam, ctx, labels, maxPred;

  // ① 相機自檢
  btnCheck.onclick = async () => {
    msgEl.style.color = '#c0392b';
    msgEl.textContent = '';
    try{
      if(!window.isSecureContext){
        throw new Error('此頁面不是 HTTPS 或 localhost，瀏覽器會封鎖相機');
      }
      const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      stream.getTracks().forEach(t=>t.stop());
      msgEl.style.color = '#27ae60';
      msgEl.textContent = '✅ 相機檢測成功，可以使用';
    }catch(e){
      msgEl.textContent = `相機自檢失敗：${e.name}\n${e.message||''}\n` +
                          '• NotAllowedError：曾按拒絕或站點權限被關。\n' +
                          '• NotFoundError：沒有可用攝影機。\n' +
                          '• 請用 HTTPS / localhost 並允許相機。';
    }
  };

  // ② 載入模型並開始
  btnStart.onclick = async () => {
    msgEl.style.color = '#c0392b';
    msgEl.textContent = '載入中…';
    try{
      if (typeof tf.fromPixels !== 'function') {
        throw new Error('tf.fromPixels 仍不可用（請用訪客模式測試，避免外掛覆蓋 TFJS）');
      }

      try{ await tf.setBackend('webgl'); }catch{ await tf.setBackend('cpu'); }
      await tf.ready();

      model = await tmPose.load(modelURL, metadataURL);
      maxPred = model.getTotalClasses();

      const size = 400, flip = true;
      webcam = new tmPose.Webcam(size, size, flip);
      await webcam.setup();
      await webcam.play();

      const canvas = document.getElementById('canvas');
      canvas.style.display = 'block';
      ctx = canvas.getContext('2d');

      labels = document.getElementById('labels');
      labels.innerHTML = '';
      for(let i=0;i<maxPred;i++) labels.appendChild(document.createElement('div'));

      msgEl.style.color = '#27ae60';
      msgEl.textContent = '✅ 模型載入完成，相機啟動成功！';
      requestAnimationFrame(loop);

    }catch(e){
      msgEl.style.color = '#c0392b';
      msgEl.textContent = '❌ 無法載入模型：\n' + (e.message||e.toString());
      console.error(e);
    }
  };

  async function loop(){
    webcam.update();
    await predict();
    requestAnimationFrame(loop);
  }

  async function predict(){
    const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
    const prediction = await model.predict(posenetOutput);

    ctx.drawImage(webcam.canvas, 0, 0);
    if(pose){
      tmPose.drawKeypoints(pose.keypoints, 0.5, ctx);
      tmPose.drawSkeleton(pose.keypoints, 0.5, ctx);
    }
    for(let i=0;i<prediction.length;i++){
      labels.childNodes[i].textContent =
        `${prediction[i].className}: ${(prediction[i].probability*100).toFixed(2)}%`;
    }
  }
})();
</script>
</body>
</html>
