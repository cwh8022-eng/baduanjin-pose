async function predictOnce(){
  // 畫面（視覺鏡像）
  if (flip){ ctx.save(); ctx.scale(-1,1); ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height); ctx.restore(); }
  else { ctx.drawImage(video,0,0,canvas.width,canvas.height); }

  // 姿勢 + 品質門檻（估姿勢時也用 flip）
  const pose = await posenetModel.estimateSinglePose(video, { flipHorizontal: flip });
  const okScores = pose.keypoints.filter(k=>k.score>0).map(k=>k.score);
  const avgScore = okScores.length ? okScores.reduce((a,b)=>a+b,0)/okScores.length : 0;
  let frameSkipped = false;

  if (avgScore < MIN_KP_SCORE){
    frameSkipped = true;
    document.getElementById('qualityNote').innerHTML =
      `⚠️ <span class="warn">人體偵測品質偏低（平均 ${avgScore.toFixed(2)}）。請：站遠一點、補光、全身入鏡、背景簡單。</span>`;
  } else {
    document.getElementById('qualityNote').textContent = '';
  }

  drawKeypoints(pose.keypoints, 0.5, ctx);
  drawSkeleton(pose.keypoints, 0.5, ctx);

  // === 取 raw outputs → 14739 → 分類（★ 已修正 flip 的維度）===
  let probs=[];
  if (!frameSkipped){
    const feat = tf.tidy(()=>{
      let t = tf.browser.fromPixels(video).toFloat();                 // [H,W,3]
      t = tf.image.resizeBilinear(t, [257,257]).div(127.5).sub(1);    // [257,257,3]
      t = t.expandDims(0);                                            // [1,257,257,3]
      if (flip) t = tf.image.flipLeftRight(t);                        // [1,257,257,3]
      const out = posenetPredictRaw(t);
      const heatmap = out.heatmapScores;                              // [1,17,17,17]
      const offsets = out.offsets;                                    // [1,17,17,34]
      const f = makeFeatures14739(heatmap, offsets);                  // [1,14739]
      t.dispose();
      return f;
    });

    const logits = classifier.predict(feat);
    const probT  = tf.softmax(logits);
    probs = Array.from(await probT.data());
    probT.dispose(); logits.dispose(); feat.dispose();
  } else {
    probs = new Array(labels.length).fill(0);
  }

  // 依 D1~D8 聚合到固定 8 條（你的既有 idxMap / DESIRED_8 不變）
  const mapDisplay = {}; DESIRED_8.forEach(n => mapDisplay[n]=0);
  for (let i=0;i<labels.length;i++){
    const d = idxMap[i];
    if (d>=0 && d<DESIRED_8.length) mapDisplay[DESIRED_8[d]] += (probs[i]||0);
  }

  // 平滑 + 遲滯 + UI 更新（沿用你原本的 smooth/lockName/LOCK_FRAMES 等）
  let topName=DESIRED_8[0], topProb=0;
  for (const name of DESIRED_8){
    const p = mapDisplay[name] ?? 0;
    const val = SMOOTH_ALPHA*p + (1-SMOOTH_ALPHA)*(smooth[name]||0);
    smooth[name]=val;

    const pct = val*100, id = name.replace(/\s+/g,'-').replace(/[^-\w]/g,'');
    const fill=document.getElementById(`fill-${id}`), txt=document.getElementById(`pct-${id}`);
    if (fill) fill.style.width = `${pct.toFixed(2)}%`;
    if (txt)  txt.textContent  = `${pct.toFixed(2)}%`;

    if (p > topProb){ topProb=p; topName=name; }
  }
  if (topName === lockName) lockCount++; else { lockName=topName; lockCount=1; }
  const stable = (lockCount>=LOCK_FRAMES)? lockName : (lastStable||lockName);
  lastStable = stable;
  document.getElementById('topClass').textContent =
    `目前辨識：${stable || '—'}（${(topProb*100).toFixed(2)}%）`;
}
