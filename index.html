<!DOCTYPE html>
<html lang="zh-Hant">
<head>
Â <meta charset="UTF-8" />
Â <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
Â <title>å…«æ®µéŒ¦å‹•ä½œè¾¨è­˜ï¼ˆé æª¢ï¼‹SHA-256ï¼‰</title>
Â 
Â Â <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
Â <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
Â 
Â <style>
Â Â Â :root { --w: 880px; }
Â Â Â body { font-family: Arial, "Noto Sans TC", system-ui; background:#f3f5f8; padding:22px 14px 40px; color:#1f2937; }
Â Â Â h1 { text-align:center; margin:0 0 10px; font-weight:700; }
Â Â Â .hint { text-align:center; color:#6b7280; margin:6px 0 12px; }
Â Â Â .wrap { width:min(var(--w), 96vw); margin:0 auto; }
Â Â Â .btns { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:12px; }
Â Â Â button { padding:10px 16px; border:0; border-radius:10px; background:#0ea5e9; color:#fff; cursor:pointer; font-size:16px; box-shadow:0 4px 14px rgba(14,165,233,.25); }
Â Â Â button:hover { filter:brightness(1.05); }
Â Â Â .stage { display:flex; gap:18px; align-items:flex-start; flex-wrap:wrap; }
Â Â Â canvas { width:min(420px, 96vw); height:auto; border-radius:12px; border:2px solid #334155; background:#000; }
Â Â Â .panel { flex:1 1 420px; min-width:320px; }
Â 
Â Â Â .row { display:grid; grid-template-columns: 180px 1fr; gap:12px; align-items:center; margin:10px 0; }
Â Â Â .name { font-weight:700; color:#374151; }
Â Â Â .track { position:relative; background:#e5e7eb; border-radius:999px; overflow:hidden; height:22px; box-shadow: inset 0 1px 1px rgba(0,0,0,.06);}
Â Â Â .bar { height:100%; width:0%; background:linear-gradient(90deg,#34d399,#10b981); color:#fff; line-height:22px; text-align:right; padding-right:8px; font-size:12px; font-weight:600; transition:width .18s ease; }
Â Â Â .cls { position:absolute; right:8px; top:-18px; font-size:11px; color:#6b7280; }
Â Â Â .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; color:#334155; text-align:left; background:#eef2ff; border:1px solid #c7d2fe; border-radius:8px; padding:10px; margin:0 auto 12px; width:min(var(--w),96vw); }
Â Â Â .ok { color:#065f46; } .bad { color:#991b1b; }
Â Â Â .muted { color:#6b7280; }
Â </style>
</head>
<body>
Â <h1>å…«æ®µéŒ¦å‹•ä½œè¾¨è­˜</h1>
Â <div class="hint">æµç¨‹ï¼šâ‘ å…ˆã€Œæª¢æŸ¥æ¨¡å‹æª”ã€â†’ â‘¡ ç¢ºèªé•·åº¦èˆ‡ SHA-256 â†’â‘¢ ã€Œå•Ÿå‹•è¾¨è­˜ã€ã€‚è«‹ä»¥ HTTPS/localhost é–‹å•Ÿä¸¦å…è¨±æ”å½±æ©Ÿã€‚</div>
Â 
Â <div class="btns">
Â Â Â <button onclick="preflightCheck()">ğŸ” æª¢æŸ¥æ¨¡å‹æª”ï¼ˆå« SHA-256ï¼‰</button>
Â Â Â <button onclick="init()">â–¶ï¸ å•Ÿå‹•è¾¨è­˜</button>
Â </div>
Â <div id="preflightLog" class="log" style="display:none;"></div>
Â 
Â <div class="wrap">
Â Â Â <div class="stage">
Â Â Â Â Â <canvas id="canvas" width="400" height="400"></canvas>
Â Â Â Â Â <div class="panel" id="list"></div>
Â Â Â </div>
Â </div>
Â 
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
<script>
Â let model, webcam, ctx, maxPredictions;
Â let indexMap = null;
Â let classNames = [];
Â let BASE = null;
Â 
Â const TARGETS = [
Â Â Â { key: 'D1', name: 'é›™æ‰‹æ‰˜å¤©ç†ä¸‰ç„¦' },
Â Â Â { key: 'D2', name: 'å·¦å³é–‹å¼“ä¼¼å°„éµ°' },
Â Â Â { key: 'D3', name: 'èª¿ç†è„¾èƒƒé ˆå–®èˆ‰' },
Â Â Â { key: 'D4', name: 'äº”å‹ä¸ƒå‚·å¾€å¾Œç§' },
Â Â Â { key: 'D5', name: 'æ–é ­æ“ºå°¾å»å¿ƒç«' },
Â Â Â { key: 'D6', name: 'å…©æ‰‹æ”€è¶³å›ºè…è…°' },
Â Â Â { key: 'D7', name: 'æ”¢æ‹³æ€’ç›®å¢æ°£åŠ›' },
Â Â Â { key: 'D8', name: 'èƒŒå¾Œä¸ƒé¡›ç™¾ç—…æ¶ˆ' }
Â ];
Â 
Â const KEYWORD_MAP = [
Â Â Â { token:'é›™æ‰‹æ‰˜å¤©', target:'D1' }, { token:'æ‰˜å¤©', target:'D1' },
Â Â Â { token:'é–‹å¼“', target:'D2' }, { token:'å°„é›•', target:'D2' }, { token:'å°„éµ°', target:'D2' },
Â Â Â { token:'å–®èˆ‰', target:'D3' }, { token:'è„¾èƒƒ', target:'D3' },
Â Â Â { token:'å¾€å¾Œç§', target:'D4' }, { token:'ä¸ƒå‚·', target:'D4' },
Â Â Â { token:'æ“ºå°¾', target:'D5' }, { token:'å»å¿ƒç«', target:'D5' },
Â Â Â { token:'æ”€è¶³', target:'D6' }, { token:'è…è…°', target:'D6' },
Â Â Â { token:'æ”¢æ‹³', target:'D7' }, { token:'å¢æ°£åŠ›', target:'D7' },
Â Â Â { token:'ä¸ƒé¡›', target:'D8' }, { token:'ç™¾ç—…æ¶ˆ', target:'D8' }
Â ];
Â 
Â function normalizeLabel(s){
Â Â Â if(!s) return '';
Â Â Â return s.replace(/\s+/g,'').replace(/æ­£ç¢º/g,'').replace(/[()ï¼ˆï¼‰\[\]ã€ã€‘ï¼š:ï¼Œ,ã€‚.\-_/]/g,'').replace(/é›•/g,'éµ°').toLowerCase();
Â }
Â 
Â function buildIndexMap(modelClassNames){
Â Â Â const map = {}; TARGETS.forEach(t=>map[t.key]=-1);
Â Â Â modelClassNames.forEach((name, idx)=>{
Â Â Â Â Â const n = normalizeLabel(name);
Â Â Â Â Â for(const rule of KEYWORD_MAP){
Â Â Â Â Â Â Â if(n.indexOf(rule.token)!==-1 && map[rule.target]===-1){
Â Â Â Â Â Â Â Â Â map[rule.target]=idx; break;
Â Â Â Â Â Â Â }
Â Â Â Â Â }
Â Â Â Â Â if(map.D1===-1 && /d1/.test(n)) map.D1=idx;
Â Â Â Â Â if(map.D2===-1 && /d2/.test(n)) map.D2=idx;
Â Â Â Â Â if(map.D3===-1 && /d3/.test(n)) map.D3=idx;
Â Â Â Â Â if(map.D4===-1 && /d4/.test(n)) map.D4=idx;
Â Â Â Â Â if(map.D5===-1 && /d5/.test(n)) map.D5=idx;
Â Â Â Â Â if(map.D6===-1 && /d6/.test(n)) map.D6=idx;
Â Â Â Â Â if(map.D7===-1 && /d7/.test(n)) map.D7=idx;
Â Â Â Â Â if(map.D8===-1 && /d8/.test(n)) map.D8=idx;
Â Â Â });
Â Â Â return map;
Â }
Â 
Â function buildUI(labels){
Â Â Â const list = document.getElementById('list');
Â Â Â list.innerHTML = '';
Â Â Â TARGETS.forEach((t, i)=>{
Â Â Â Â Â const row=document.createElement('div'); row.className='row';
Â Â Â Â Â const name=document.createElement('div'); name.className='name'; name.textContent = `${i+1}. ${t.name}`;
Â Â Â Â Â const track=document.createElement('div'); track.className='track';
Â Â Â Â Â const bar=document.createElement('div'); bar.className='bar'; bar.id=`bar-${t.key}`; bar.textContent='0.0%';
Â Â Â Â Â const cls=document.createElement('div'); cls.className='cls'; cls.id=`cls-${t.key}`; cls.textContent='';
Â Â Â Â Â track.appendChild(bar); track.appendChild(cls);
Â Â Â Â Â row.appendChild(name); row.appendChild(track);
Â Â Â Â Â list.appendChild(row);
Â Â Â });
Â Â Â if(indexMap){
Â Â Â Â Â TARGETS.forEach(t=>{
Â Â Â Â Â Â Â const idx=indexMap[t.key];
Â Â Â Â Â Â Â const label = (idx>=0 && labels[idx]) ? labels[idx] : 'ï¼ˆæœªå°æ‡‰ï¼‰';
Â Â Â Â Â Â Â const el = document.getElementById(`cls-${t.key}`);
Â Â Â Â Â Â Â if(el) el.textContent = label;
Â Â Â Â Â });
Â Â Â }
Â }
Â 
Â function showLog(){ document.getElementById('preflightLog').style.display='block'; }
Â function logLine(s, cls=''){ const box=document.getElementById('preflightLog'); box.innerHTML += `<div class="${cls}">${s}</div>`; }
Â 
Â function toHex(uint8){
Â Â Â return Array.from(uint8).map(b=>b.toString(16).padStart(2,'0')).join('');
Â }
Â 
Â async function preflightCheck(){
Â Â Â const box = document.getElementById('preflightLog');
Â Â Â box.innerHTML=''; showLog(); logLine('é–‹å§‹æª¢æŸ¥â€¦');
Â 
Â Â Â BASE = location.origin + (location.pathname.endsWith('/') ? location.pathname : location.pathname.replace(/[^/]+$/, '/'));
Â Â Â const modelURLÂ Â Â  = BASE + 'model.json?v=' + Date.now();
Â Â Â const metadataURL = BASE + 'metadata.json?v=' + Date.now();
Â Â Â const weightsURLÂ  = BASE + 'weights.bin?v=' + Date.now();
Â Â Â logLine(JSON.stringify({modelURL, metadataURL, weightsURL}), 'muted');
Â 
Â Â Â try {
Â Â Â Â Â const mRes = await fetch(modelURL, {cache:'no-store'});
Â Â Â Â Â if (!mRes.ok) throw new Error(`model.json HTTP ${mRes.status}`);
Â Â Â Â Â const mJson = await mRes.json();
Â Â Â Â Â const manifestPaths = (mJson.weightsManifest && mJson.weightsManifest[0] && mJson.weightsManifest[0].paths) || [];
Â Â Â Â Â logLine(`âœ” model.json å–å¾—æˆåŠŸï¼›manifest paths=${JSON.stringify(manifestPaths)}`, 'ok');
Â 
Â Â Â Â Â const wRes = await fetch(weightsURL, {cache:'no-store'});
Â Â Â Â Â if (!wRes.ok) throw new Error(`weights.bin(GET) HTTP ${wRes.status}`);
Â Â Â Â Â const buf = await wRes.arrayBuffer();
Â Â Â Â Â const byteLen = buf.byteLength;
Â Â Â Â Â logLine(`weights.bin è§£å£“å¾Œ byteLength = ${byteLen}`);
Â Â Â Â Â if (byteLen === 0 || (byteLen % 4) !== 0) {
Â Â Â Â Â Â Â throw new Error('weights.bin è§£å£“å¾Œé•·åº¦ä¸æ˜¯ 4 çš„å€æ•¸ï¼Œæª”æ¡ˆå¯èƒ½ä¸å®Œæ•´ã€‚');
Â Â Â Â Â }
Â 
Â Â Â Â Â const digest = await crypto.subtle.digest('SHA-256', buf);
Â Â Â Â Â const shaHex = toHex(new Uint8Array(digest));
Â Â Â Â Â logLine(`SHA-256ï¼ˆç·šä¸Š weights.binï¼‰= <b>${shaHex}</b>`, 'ok');
Â Â Â Â Â logLine('âœ… é æª¢é€šéï¼šè«‹æ¯”å°æœ¬æ©Ÿ weights.bin çš„ SHA-256 æ˜¯å¦ç›¸åŒï¼Œè‹¥ç›¸åŒå³å¯å•Ÿå‹•è¾¨è­˜ã€‚', 'ok');
Â 
Â Â Â Â Â const head16 = new Uint8Array(buf.slice(0, 16));
Â Â Â Â Â logLine('å‰ 16 bytesï¼š[' + Array.from(head16).join(', ') + ']', 'muted');
Â 
Â Â Â Â Â logLine('æœ¬æ©Ÿæª”æ¡ˆ SHA-256 è¨ˆç®—æ–¹å¼ï¼š', 'muted');
Â Â Â Â Â logLine('Windows PowerShellï¼šÂ  Get-FileHash -Algorithm SHA256 .\\weights.bin', 'muted');
Â Â Â Â Â logLine('macOS / Linuxï¼šÂ Â Â Â Â  shasum -a 256 weights.bin', 'muted');
Â Â Â } catch (e){
Â Â Â Â Â logLine('âŒ é æª¢å¤±æ•—ï¼š' + e.message + 'ï¼ˆè«‹æ¸…å¿«å–é‡è¼‰æˆ–é‡æ–°ä¸Šå‚³æª”æ¡ˆï¼‰', 'bad');
Â Â Â }
Â }
Â 
Â async function init(){
Â Â Â BASE = BASE || (location.origin + (location.pathname.endsWith('/') ? location.pathname : location.pathname.replace(/[^/]+$/,'/')));
Â Â Â const modelURLÂ Â Â  = BASE + 'model.json';
Â Â Â const metadataURL = BASE + 'metadata.json';
Â Â Â console.log('[model paths]', {modelURL, metadataURL});
Â 
Â Â Â model = await tmPose.load(modelURL, metadataURL);
Â Â Â maxPredictions = model.getTotalClasses();
Â 
Â Â Â let labels=[];
Â Â Â try{
Â Â Â Â Â const meta = await fetch(metadataURL, {cache:'no-store'}).then(r=>r.json());
Â Â Â Â Â const rawÂ  = meta.labels || meta.classes || [];
Â Â Â Â Â labels = raw.map(x => (x && x.label) ? x.label : (typeof x==='string' ? x : ''));
Â Â Â }catch(_){}
Â Â Â if(!labels.length) labels = new Array(maxPredictions).fill('');
Â 
Â Â Â indexMap = buildIndexMap(labels);
Â Â Â classNames = labels.slice();
Â Â Â buildUI(classNames);
Â 
Â Â Â const size=400, flip=true;
Â Â Â webcam = new tmPose.Webcam(size, size, flip);
Â Â Â await webcam.setup();
Â Â Â await webcam.play();
Â 
Â Â Â const canvas=document.getElementById('canvas');
Â Â Â ctx=canvas.getContext('2d');
Â 
Â Â Â window.requestAnimationFrame(loop);
Â }
Â 
Â async function loop(){
Â Â Â webcam.update();
Â Â Â await predict();
Â Â Â window.requestAnimationFrame(loop);
Â }
Â 
Â async function predict(){
Â Â Â const videoEl = webcam && webcam.webcam;
Â Â Â if(!videoEl || videoEl.readyState < 2) return;
Â 
Â Â Â const { pose, posenetOutput } = await model.estimatePose(videoEl);
Â Â Â const prediction = await model.predict(posenetOutput);
Â 
Â Â Â if(!classNames.filter(Boolean).length){
Â Â Â Â Â classNames = prediction.map(p => p.className || '');
Â Â Â Â Â indexMap = buildIndexMap(classNames);
Â Â Â Â Â buildUI(classNames);
Â Â Â }
Â 
Â Â Â // å°‡å½±åƒå’Œéª¨æ¶éƒ½æ°´å¹³ç¿»è½‰ï¼Œç¢ºä¿æ­£ç¢ºå°é½Š
Â Â Â ctx.save();
Â Â Â ctx.scale(-1, 1);
Â Â Â ctx.drawImage(videoEl, -ctx.canvas.width, 0, ctx.canvas.width, ctx.canvas.height);
Â 
Â Â Â if(pose){
Â Â Â Â Â tmPose.drawKeypoints(pose.keypoints, 0.5, ctx);
Â Â Â Â Â tmPose.drawSkeleton(pose.keypoints, 0.5, ctx);
Â Â Â }
Â Â Â ctx.restore();
Â 
Â Â Â for(const t of TARGETS){
Â Â Â Â Â const idx = indexMap ? indexMap[t.key] : -1;
Â Â Â Â Â const p = (idx>=0 && prediction[idx]) ? (prediction[idx].probability || 0) : 0;
Â Â Â Â Â const pct = (p*100).toFixed(1) + '%';
Â Â Â Â Â const bar = document.getElementById(`bar-${t.key}`);
Â Â Â Â Â if(bar){ bar.style.width = pct; bar.textContent = pct; }
Â Â Â }
Â }
</script>
</body>
</html>
