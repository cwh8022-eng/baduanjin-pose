<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>八段錦辨識（分類條・強化防覆寫版）</title>
  <style>
    :root{color-scheme:light dark}
    body{font-family:Arial,Helvetica,sans-serif;background:#f0f4f8;margin:0;padding:20px;text-align:center}
    h1{color:#2c3e50;margin:6px 0 12px}
    #ver{color:#555;margin:4px 0 12px}
    #msg{margin:8px 0 14px;font-weight:700;color:#c0392b;white-space:pre-line}
    .btn{margin:8px 6px;padding:10px 16px;font-size:15px;border:0;border-radius:8px;background:#2980b9;color:#fff;cursor:pointer}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .wrap{max-width:1080px;margin:0 auto;display:grid;grid-template-columns:420px 1fr;gap:16px;align-items:start}
    canvas{display:block;margin:0 auto;border:2px solid #2c3e50;border-radius:12px;background:#000}
    .panel{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:12px 14px;text-align:left}
    .title{font-size:14px;color:#6b7280;margin:0 0 8px}
    #topClass{font-size:20px;font-weight:800;color:#1f2937;margin-bottom:8px}
    .bar{display:flex;align-items:center;gap:10px;margin:8px 0}
    .bar-name{width:150px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#1f2937}
    .bar-track{flex:1;height:14px;background:#e5e7eb;border-radius:999px;overflow:hidden}
    .bar-fill{height:100%;width:0%;background:#10b981;transition:width .15s linear}
    .bar-pct{width:60px;text-align:right;color:#374151;font-variant-numeric:tabular-nums}
    @media (max-width:900px){.wrap{grid-template-columns:1fr}}
  </style>

  <!-- 1) 先載 tfjs 1.7.4（含 fromPixels） -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"></script>

  <!-- 2) 監控/攔截任何對 window.tf 的覆寫，並自動修補 fromPixels -->
  <script>
    (function guardTF(){
      // 工具：把 fromPixels 修好（支援新舊 API）
      function ensureFromPixels(tf) {
        if (!tf) return;
        var hasOld = typeof tf.fromPixels === 'function';
        var hasNew = tf.browser && typeof tf.browser.fromPixels === 'function';
        if (!hasOld && hasNew) {
          try {
            Object.defineProperty(tf, 'fromPixels', {
              value: tf.browser.fromPixels.bind(tf.browser),
              writable: false, configurable: false
            });
          } catch (_) { tf.fromPixels = tf.browser.fromPixels.bind(tf.browser); }
          console.log('[guard] patched tf.fromPixels from tf.browser.fromPixels');
        }
        return typeof tf.fromPixels === 'function';
      }

      // 1) 先對目前的 tf 做一次修補
      ensureFromPixels(window.tf);

      // 2) 攔截「之後」任何對 window.tf 的覆寫
      var _tf = window.tf;
      try {
        Object.defineProperty(window, 'tf', {
          configurable: true,
          get() { return _tf; },
          set(v) {
            _tf = v;
            var ok = ensureFromPixels(_tf);
            console.warn('[guard] window.tf was replaced, fromPixels ok =', ok);
          }
        });
        console.log('[guard] window.tf setter installed');
      } catch (e) {
        console.warn('[guard] cannot install setter, fallback to watcher', e);
        // 3) 若環境不允許 setter，就用輪詢監控
        var last = window.tf;
        setInterval(function(){
          if (window.tf !== last) {
            last = window.tf;
            var ok = ensureFromPixels(last);
            console.warn('[guard] window.tf changed, fromPixels ok =', ok);
          }
        }, 400);
      }
    })();
  </script>

  <!-- 3) 再載 Teachable Machine Pose（必須在 guard 之後） -->
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>
</head>
<body>
  <h1>八段錦動作辨識（分類條）</h1>
  <div id="ver">初始化中…</div>

  <button id="btnCheck" class="btn">① 相機自檢</button>
  <button id="btnStart" class="btn">② 載入模型並開始</button>

  <div id="msg"></div>

  <div class="wrap">
    <canvas id="canvas" width="400" height="400"></canvas>

    <div class="panel">
      <p class="title">即時辨識結果</p>
      <div id="topClass">尚未開始</div>
      <div id="bars"></div>
    </div>
  </div>

<script>
(function(){
  const verEl = document.getElementById('ver');
  const msgEl = document.getElementById('msg');
  const btnCheck = document.getElementById('btnCheck');
  const btnStart = document.getElementById('btnStart');

  const tfv = (window.tf && tf.version && tf.version.tfjs) ? tf.version.tfjs : '未載';
  const hasFP = (typeof (window.tf && tf.fromPixels) === 'function');
  verEl.textContent = `SecureContext=${window.isSecureContext} | tfjs=${tfv} | has fromPixels=${hasFP}`;

  const modelURL    = './model.json';
  const metadataURL = './metadata.json';

  let model, webcam, ctx, maxPred = 0;
  let classNames = [];
  let barsBuilt = false;
  let smooth = {};

  btnCheck.onclick = async () => {
    msgEl.style.color = '#c0392b'; msgEl.textContent = '';
    try{
      if(!window.isSecureContext) throw new Error('此頁面不是 HTTPS 或 localhost，瀏覽器會封鎖相機');
      const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      stream.getTracks().forEach(t=>t.stop());
      msgEl.style.color = '#27ae60';
      msgEl.textContent = '✅ 相機檢測成功，可以使用';
    }catch(e){
      msgEl.textContent = `相機自檢失敗：${e.name}\n${e.message||''}\n` +
                          '• NotAllowedError：曾按拒絕或站點權限被關。\n' +
                          '• NotFoundError：沒有可用攝影機。\n' +
                          '• 請用 HTTPS / localhost 並允許相機。';
    }
  };

  btnStart.onclick = async () => {
    msgEl.style.color = '#c0392b'; msgEl.textContent = '載入中…';
    try{
      if (typeof tf.fromPixels !== 'function') {
        throw new Error('tf.fromPixels 不可用：當前頁面的 TFJS 被外掛或其它腳本覆蓋。若仍無法運行，請用 Chrome「訪客模式」開啟此頁。');
      }

      try{ await tf.setBackend('webgl'); }catch{ await tf.setBackend('cpu'); }
      await tf.ready();

      await mustOk(modelURL, 'model.json');
      await mustOk(metadataURL, 'metadata.json');

      model = await tmPose.load(modelURL, metadataURL);
      maxPred = model.getTotalClasses();

      const size = 400, flip = true;
      const canvas = document.getElementById('canvas');
      ctx = canvas.getContext('2d');

      const cam = new tmPose.Webcam(size, size, flip);
      await cam.setup();
      await cam.play();
      window.webcam = cam;

      msgEl.style.color = '#27ae60';
      msgEl.textContent = '✅ 模型載入完成，相機啟動成功！';
      requestAnimationFrame(loop);

    }catch(e){
      msgEl.style.color = '#c0392b';
      msgEl.textContent = '❌ 無法載入模型或啟動相機：\n' + (e.message||e.toString());
      console.error(e);
    }
  };

  function buildBars(names){
    const bars = document.getElementById('bars');
    bars.innerHTML = '';
    names.forEach(n=>{
      const row = document.createElement('div');
      row.className = 'bar';
      row.innerHTML = `
        <div class="bar-name" title="${n}">${n}</div>
        <div class="bar-track"><div class="bar-fill" id="fill-${cssId(n)}" style="width:0%"></div></div>
        <div class="bar-pct" id="pct-${cssId(n)}">0.00%</div>
      `;
      bars.appendChild(row);
      smooth[n] = 0;
    });
    barsBuilt = true;
  }

  function cssId(name){ return name.replace(/\s+/g,'-').replace(/[^-\w]/g,''); }

  async function loop(){
    if (!window.webcam) { requestAnimationFrame(loop); return; }
    window.webcam.update();
    await predict();
    requestAnimationFrame(loop);
  }

  async function predict(){
    const { pose, posenetOutput } = await model.estimatePose(window.webcam.canvas);
    const preds = await model.predict(posenetOutput);

    if (!barsBuilt) {
      classNames = preds.map(p=>p.className);
      buildBars(classNames);
    }

    ctx.drawImage(window.webcam.canvas, 0, 0);
    if (pose) {
      tmPose.drawKeypoints(pose.keypoints, 0.5, ctx);
      tmPose.drawSkeleton(pose.keypoints, 0.5, ctx);
    }

    let top = {className:'', probability:0};
    const alpha = 0.35;
    preds.forEach(p=>{
      const prev = smooth[p.className] ?? 0;
      const val = alpha * p.probability + (1 - alpha) * prev;
      smooth[p.className] = val;

      const pct = (val * 100);
      const id = cssId(p.className);
      const fill = document.getElementById(`fill-${id}`);
      const label = document.getElementById(`pct-${id}`);
      if (fill) fill.style.width = `${pct.toFixed(2)}%`;
      if (label) label.textContent = `${pct.toFixed(2)}%`;

      if (p.probability > top.probability) top = p;
    });

    const topEl = document.getElementById('topClass');
    topEl.textContent = `目前辨識：${top.className}（${(top.probability*100).toFixed(2)}%）`;
  }

  async function mustOk(url, name){
    const r = await fetch(url, { cache:'no-store' });
    if(!r.ok) throw new Error(`${name} HTTP ${r.status}（找不到或被阻擋）`);
    return r;
  }
})();
</script>
</body>
</html>
