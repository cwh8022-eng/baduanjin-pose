<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>八段錦動作辨識（穩定化＋品質門檻＋labels 對齊）</title>
  <style>
    :root{color-scheme:light dark}
    body{font-family:Arial,Helvetica,sans-serif;background:#f0f4f8;margin:0;padding:20px;text-align:center}
    h1{color:#2c3e50;margin:6px 0 12px}
    #ver{color:#555;margin:4px 0 12px}
    #msg{margin:8px 0 14px;font-weight:700;white-space:pre-line}
    .ok{color:#16a34a}.bad{color:#dc2626}.warn{color:#b45309}
    .btn{margin:8px 6px;padding:10px 16px;font-size:15px;border:0;border-radius:8px;background:#2563eb;color:#fff;cursor:pointer}
    .btn.secondary{background:#6b7280}
    .wrap{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:420px 1fr;gap:16px;align-items:start}
    canvas{display:block;margin:0 auto;border:2px solid #2c3e50;border-radius:12px;background:#000}
    video{position:absolute;left:-9999px;top:-9999px;width:0;height:0}
    .panel{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:12px 14px;text-align:left}
    .title{font-size:14px;color:#6b7280;margin:0 0 8px}
    #topClass{font-size:20px;font-weight:800;color:#1f2937;margin:8px 0}
    .bar{display:flex;align-items:center;gap:10px;margin:8px 0}
    .bar-name{width:220px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#1f2937}
    .bar-track{flex:1;height:14px;background:#e5e7eb;border-radius:999px;overflow:hidden}
    .bar-fill{height:100%;width:0%;background:#10b981;transition:width .12s linear}
    .bar-pct{width:72px;text-align:right;color:#374151;font-variant-numeric:tabular-nums}
    .note{font-size:13px;color:#6b7280;margin-top:6px}
    .dbg{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px;margin-top:10px;white-space:pre-wrap}
    @media (max-width:900px){.wrap{grid-template-columns:1fr}}
  </style>

  <!-- 我們用 PoseNet + 你本地的分類器，完全不載 tmPose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.1/dist/posenet.min.js"></script>
</head>
<body>
  <h1>八段錦動作辨識</h1>
  <div id="ver">初始化中…</div>

  <button id="btnCheck" class="btn">① 相機自檢</button>
  <button id="btnStart" class="btn">② 載入模型並開始</button>
  <button id="btnFlip" class="btn secondary" title="前鏡頭通常需鏡像">切換鏡像：開</button>
  <button id="btnCamFacing" class="btn secondary" title="切換前/後鏡頭">鏡頭：前</button>

  <div id="msg"></div>

  <div class="wrap">
    <canvas id="canvas" width="400" height="400"></canvas>

    <div>
      <div class="panel">
        <p class="title">即時辨識結果</p>
        <div id="topClass">尚未開始</div>
        <div id="bars"></div>
        <div id="labelWarn" class="note"></div>
        <div id="qualityNote" class="note"></div>
      </div>

      <div class="panel">
        <p class="title">除錯面板（自動更新）</p>
        <div id="debug" class="dbg">等待開始…</div>
      </div>
    </div>
  </div>

  <video id="video" playsinline autoplay muted></video>

<script>
(function(){
  // ===== 你希望顯示的八段錦名稱（如和 metadata 不同，會 fallback 並提示）=====
  const DESIRED_NAMES = [
    '雙手托天理三焦',
    '左右開弓似射雕',
    '調理脾胃須單舉',
    '五勞七傷往後瞧',
    '搖頭擺尾去心火',
    '兩手攀足固腎腰',
    '攢拳怒目增氣力',
    '背後七顛百病消'
  ];

  // （可選）若你的 metadata.labels 跟上面字面不同，這裡做別名對照：左邊=metadata 的名字，右邊=想顯示的名字
  // 例： 'Shuang Shou Tuo Tian' : '雙手托天理三焦'
  const aliasMap = {
    // 'Shuang Shou Tuo Tian' : '雙手托天理三焦'
  };

  // ===== 檔案路徑 =====
  const modelURL    = './model.json';
  const metadataURL = './metadata.json';

  // ===== PoseNet 參數（與 TM 常見設定一致）=====
  const PNET_CFG = {
    architecture: 'MobileNetV1',
    outputStride: 16,
    inputResolution: { width: 257, height: 257 },
    multiplier: 0.75
  };

  // ===== 辨識穩定化參數 =====
  const SMOOTH_ALPHA = 0.2;     // 指數平滑（越小越穩）
  const LOCK_FRAMES  = 8;       // 需要連續 N 幀 top-1 才切換
  const MIN_KP_SCORE = 0.3;     // 關鍵點平均分數門檻（低於此值略過該幀）
  const SKIP_MSG_COOLDOWN = 20; // 顯示品質提示的冷卻幀數

  // ===== DOM =====
  const verEl   = document.getElementById('ver');
  const msgEl   = document.getElementById('msg');
  const video   = document.getElementById('video');
  const canvas  = document.getElementById('canvas');
  const ctx     = canvas.getContext('2d');
  const dbg     = document.getElementById('debug');
  const barsEl  = document.getElementById('bars');
  const $       = id => document.getElementById(id);
  const cssId   = n => n.replace(/\s+/g,'-').replace(/[^-\w]/g,'');

  let classifier, labels=[], posenetModel;
  let running=false, flip=true, facingMode='user'; // user=前鏡頭, environment=後鏡頭
  let displayOrder=[], smooth={}, lastStable=''; 
  let lockName='', lockCount=0, skipMsgCooldown=0;

  verEl.textContent = `SecureContext=${window.isSecureContext} | tfjs=${(tf&&tf.version&&tf.version.tfjs)||'未載'} | backend=${tf.getBackend()||'-'}`;
  function info(t, ok){ msgEl.className = ok===true?'ok':(ok===false?'bad':''); msgEl.textContent = t; }

  // === 相機自檢 ===
  document.getElementById('btnCheck').onclick = async ()=>{
    info('');
    try{
      if(!window.isSecureContext) throw new Error('此頁面不是 HTTPS 或 localhost，瀏覽器會封鎖相機');
      const st = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      st.getTracks().forEach(t=>t.stop());
      info('✅ 相機檢測成功，可以使用', true);
    }catch(e){
      info(`相機自檢失敗：${e.name}\n${e.message||''}\n• NotAllowedError：曾按拒絕或站點權限被關。\n• NotFoundError：沒有可用攝影機。\n• 請用 HTTPS / localhost 並允許相機。`, false);
    }
  };

  // === 鏡像切換 ===
  document.getElementById('btnFlip').onclick = ()=>{
    flip = !flip;
    document.getElementById('btnFlip').textContent = `切換鏡像：${flip?'開':'關'}`;
  };

  // === 前/後鏡頭切換（需要重新啟動串流）===
  document.getElementById('btnCamFacing').onclick = async ()=>{
    facingMode = (facingMode==='user') ? 'environment' : 'user';
    document.getElementById('btnCamFacing').textContent = `鏡頭：${facingMode==='user'?'前':'後'}`;
    if (running) await restartStream(); // 重新開相機
  };

  // === 開始 ===
  document.getElementById('btnStart').onclick = async ()=>{
    try{
      info('載入中…');
      try{ await tf.setBackend('webgl'); }catch{ await tf.setBackend('cpu'); }
      await tf.ready();

      // 讀 metadata → labels
      const meta = await fetch(metadataURL,{cache:'no-store'}).then(r=>r.json());
      labels = meta.labels || meta.classes || [];
      if (!Array.isArray(labels) || labels.length === 0) throw new Error('metadata.json 缺少 labels');

      // 載入分類器
      await fetch(modelURL,{cache:'no-store'}).then(r=>{ if(!r.ok) throw new Error(`model.json HTTP ${r.status}`); });
      classifier = await tf.loadLayersModel(modelURL);

      // 載入 PoseNet
      posenetModel = await posenet.load(PNET_CFG);

      // 建立顯示順序
      prepareDisplayOrder();

      // 啟動相機
      await restartStream();

      canvas.width = 400; canvas.height = 400;
      info('✅ 模型載入完成，相機啟動成功！', true);
      running = true;
      requestAnimationFrame(loop);
    }catch(e){
      info('❌ 無法載入：\n' + (e.message||e.toString()), false);
      console.error(e);
    }
  };

  async function restartStream(){
    try{
      const stOld = video.srcObject;
      if (stOld) stOld.getTracks().forEach(t=>t.stop());
    }catch(_){}
    const st = await navigator.mediaDevices.getUserMedia({ video:{ facingMode }, audio:false });
    video.srcObject = st;
    await video.play();
  }

  function prepareDisplayOrder(){
    // 用 aliasMap 將 metadata.labels 轉成你想顯示的中文；沒對到就用原名
    const mapped = labels.map(n => aliasMap[n] || n);
    // 嘗試用 DESIRED_NAMES 的順序（需每個都存在於 mapped）
    const set = new Set(mapped);
    const missing = DESIRED_NAMES.filter(n=>!set.has(n));
    if (missing.length){
      displayOrder = mapped.slice(); // fallback：用 metadata 的實際順序
      $('labelWarn').innerHTML = `⚠️ <span class="warn">你的八式名稱與模型 labels 不完全一致，已改以模型的 labels 順序顯示。</span><br>缺少：<b>${missing.join('、')}</b>`;
    }else{
      displayOrder = DESIRED_NAMES.slice();
      $('labelWarn').textContent = '';
    }
    // 建條
    barsEl.innerHTML = '';
    smooth = {};
    displayOrder.forEach(n=>{
      smooth[n]=0;
      const id = cssId(n);
      const row = document.createElement('div');
      row.className='bar';
      row.innerHTML = `
        <div class="bar-name" title="${n}">${n}</div>
        <div class="bar-track"><div class="bar-fill" id="fill-${id}" style="width:0%"></div></div>
        <div class="bar-pct" id="pct-${id}">0.00%</div>`;
      barsEl.appendChild(row);
    });
    dbg.textContent = `labels(from metadata): ${JSON.stringify(labels)}\nusing order: ${JSON.stringify(displayOrder)}\n`;
  }

  function makeFeatures14739(heatmap, offsets){
    const h = heatmap.reshape([17*17*17]);
    const o = offsets.reshape([17*17*34]);
    const concat = tf.concat([h, o]);
    const out = concat.reshape([1, 14739]);
    h.dispose(); o.dispose(); concat.dispose();
    return out;
  }
  function posenetPredictRaw(img3d){ return posenetModel.baseModel.predict(img3d); }

  async function loop(){
    if(!running) return;
    await predictOnce();
    requestAnimationFrame(loop);
  }

  async function predictOnce(){
    // 畫面（鏡像）
    if (flip){ ctx.save(); ctx.scale(-1,1); ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height); ctx.restore(); }
    else { ctx.drawImage(video,0,0,canvas.width,canvas.height); }

    // 估姿勢（畫線 + 品質門檻用）
    const pose = await posenetModel.estimateSinglePose(video, { flipHorizontal: flip });

    // 計算平均關鍵點分數，若太低則略過該幀
    const okScores = pose.keypoints.filter(k=>k.score>0.0).map(k=>k.score);
    const avgScore = okScores.length ? okScores.reduce((a,b)=>a+b,0)/okScores.length : 0;
    let frameSkipped = false;

    if (avgScore < MIN_KP_SCORE){
      frameSkipped = true;
      // 顯示品質建議（每隔幾幀顯示一次）
      if (skipMsgCooldown<=0){
        $('qualityNote').innerHTML = `⚠️ <span class="warn">人體偵測品質偏低（平均 ${avgScore.toFixed(2)}）。請：</span>
        <br>• 站遠一點、讓身體全入鏡；<br>• 光線要均勻（不要逆光）；<br>• 背景簡單、與衣服顏色有對比。`;
        skipMsgCooldown = SKIP_MSG_COOLDOWN;
      }else{
        skipMsgCooldown--;
      }
    }else{
      $('qualityNote').textContent = '';
      skipMsgCooldown = 0;
    }

    // 畫關鍵點/骨架（無論是否略過都畫，以利排位）
    drawKeypoints(pose.keypoints, 0.5, ctx);
    drawSkeleton(pose.keypoints, 0.5, ctx);

    let probs = null;

    if (!frameSkipped){
      // 取 raw outputs → 14739 特徵
      const feat = tf.tidy(()=>{
        let t = tf.browser.fromPixels(video);                // [H,W,3]
        t = tf.image.resizeBilinear(t, [257,257]).toFloat(); // [257,257,3]
        t = t.div(127.5).sub(1);                             // [-1,1]
        const out = posenetPredictRaw(t);                    // batched internally
        const heatmap = out.heatmapScores;                   // [1,17,17,17]
        const offsets = out.offsets;                         // [1,17,17,34]
        const f = makeFeatures14739(heatmap, offsets);       // [1,14739]
        t.dispose();
        return f;
      });

      // 分類
      const pred = classifier.predict(feat);
      probs = Array.from(await pred.data());
      pred.dispose(); feat.dispose();
    } else {
      // 略過則用上一幀平滑值（或等價地以 0 慢慢回落）
      probs = displayOrder.map(()=>0);
    }

    // 建 map：metadata.labels → 機率
    // 先把 metadata 名稱經 aliasMap 轉成展示名，以便與 displayOrder 一致
    const mappedLabels = labels.map(n => aliasMap[n] || n);
    const map = {};
    mappedLabels.forEach((name,i)=> map[name] = probs[i] || 0);

    // 指數平滑 + 八幀鎖定（避免類別跳動）
    let topName = displayOrder[0] || '', topProb = 0;
    for (const name of displayOrder){
      const p = map[name] ?? 0;
      const val = SMOOTH_ALPHA*p + (1-SMOOTH_ALPHA)*(smooth[name]||0);
      smooth[name] = val;

      const pct = val*100;
      const id  = cssId(name);
      const fill = document.getElementById(`fill-${id}`);
      const txt  = document.getElementById(`pct-${id}`);
      if (fill) fill.style.width = `${pct.toFixed(2)}%`;
      if (txt)  txt.textContent  = `${pct.toFixed(2)}%`;

      if (p > topProb){ topProb = p; topName = name; }
    }

    // 遲滯：需要連續 LOCK_FRAMES 幀 topName 相同才切換
    if (topName === lockName){
      lockCount++;
    } else {
      lockName = topName;
      lockCount = 1;
    }
    const stable = (lockCount >= LOCK_FRAMES) ? lockName : (lastStable || lockName);
    lastStable = stable;

    document.getElementById('topClass').textContent =
      `目前辨識：${stable || '—'}（${(topProb*100).toFixed(2)}%）`;

    // 除錯面板：top3
    const pairs = mappedLabels.map((n,i)=>({n, p: probs[i]||0}));
    pairs.sort((a,b)=>b.p-a.p);
    const top3 = pairs.slice(0,3).map(x=>`${x.n}=${(x.p*100).toFixed(2)}%`).join(' | ');
    dbg.textContent =
      `labels(from metadata): ${JSON.stringify(labels)}\n` +
      `display (after aliasMap): ${JSON.stringify(mappedLabels)}\n` +
      `using order: ${JSON.stringify(displayOrder)}\n` +
      `avg keypoint score: ${avgScore.toFixed(2)}  ${frameSkipped ? '(frame skipped)' : ''}\n` +
      `top3: ${top3}\n`;
  }

  // ====== 畫關鍵點/骨架 ======
  function toTuple({y, x}) { return [x, y]; }
  function drawKeypoints(keypoints, minConfidence, ctx) {
    keypoints.forEach(kp=>{
      if (kp.score < minConfidence) return;
      const {y, x} = kp.position;
      ctx.beginPath(); ctx.arc(x, y, 3, 0, 2*Math.PI);
      ctx.fillStyle = 'rgba(16,185,129,0.9)'; ctx.fill();
    });
  }
  const adjacentKeyPoints = [
    [5,7],[7,9],[6,8],[8,10],[5,6],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]
  ];
  function drawSkeleton(keypoints, minConfidence, ctx) {
    adjacentKeyPoints.forEach(([i,j])=>{
      const kp1 = keypoints[i], kp2 = keypoints[j];
      if (kp1.score < minConfidence || kp2.score < minConfidence) return;
      ctx.beginPath();
      const [x1,y1] = toTuple(kp1.position);
      const [x2,y2] = toTuple(kp2.position);
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(59,130,246,0.9)'; ctx.stroke();
    });
  }
})();
</script>
</body>
</html>
