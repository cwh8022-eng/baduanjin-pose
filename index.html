<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>八段錦動作辨識（自動對齊 labels + 除錯面板）</title>
  <style>
    :root{color-scheme:light dark}
    body{font-family:Arial,Helvetica,sans-serif;background:#f0f4f8;margin:0;padding:20px;text-align:center}
    h1{color:#2c3e50;margin:6px 0 12px}
    #ver{color:#555;margin:4px 0 12px}
    #msg{margin:8px 0 14px;font-weight:700;white-space:pre-line}
    .ok{color:#16a34a}.bad{color:#dc2626}.warn{color:#ca8a04}
    .btn{margin:8px 6px;padding:10px 16px;font-size:15px;border:0;border-radius:8px;background:#2980b9;color:#fff;cursor:pointer}
    .wrap{max-width:1100px;margin:0 auto;display:grid;grid-template-columns:420px 1fr;gap:16px;align-items:start}
    canvas{display:block;margin:0 auto;border:2px solid #2c3e50;border-radius:12px;background:#000}
    .panel{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:12px 14px;text-align:left}
    .title{font-size:14px;color:#6b7280;margin:0 0 8px}
    #topClass{font-size:20px;font-weight:800;color:#1f2937;margin:8px 0}
    .bar{display:flex;align-items:center;gap:10px;margin:8px 0}
    .bar-name{width:200px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#1f2937}
    .bar-track{flex:1;height:14px;background:#e5e7eb;border-radius:999px;overflow:hidden}
    .bar-fill{height:100%;width:0%;background:#10b981;transition:width .12s linear}
    .bar-pct{width:72px;text-align:right;color:#374151;font-variant-numeric:tabular-nums}
    .note{font-size:13px;color:#6b7280;margin-top:6px}
    .dbg{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:13px;background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:10px;margin-top:10px;white-space:pre-wrap}
    video{position:absolute;left:-9999px;top:-9999px;width:0;height:0}
    @media (max-width:900px){.wrap{grid-template-columns:1fr}}
  </style>

  <!-- TFJS 3.11（不載 tmPose） -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
  <!-- PoseNet 2.2.1 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet@2.2.1/dist/posenet.min.js"></script>
</head>
<body>
  <h1>八段錦動作辨識</h1>
  <div id="ver">初始化中…</div>

  <button id="btnCheck" class="btn">① 相機自檢</button>
  <button id="btnStart" class="btn">② 載入模型並開始</button>

  <div id="msg"></div>

  <div class="wrap">
    <canvas id="canvas" width="400" height="400"></canvas>

    <div>
      <div class="panel">
        <p class="title">即時辨識結果</p>
        <div id="topClass">尚未開始</div>
        <div id="bars"></div>
        <div id="labelWarn" class="note"></div>
      </div>

      <div class="panel">
        <p class="title">除錯面板（自動更新）</p>
        <div id="debug" class="dbg">等待開始…</div>
      </div>
    </div>
  </div>

  <video id="video" playsinline autoplay muted></video>

<script>
(function(){
  // ➤ 你希望的固定顯示順序（若名稱與 metadata.labels 不同，系統會自動 fallback）
  const DESIRED_EIGHT = [
    '雙手托天理三焦',
    '左右開弓似射雕',
    '調理脾胃須單舉',
    '五勞七傷往後瞧',
    '搖頭擺尾去心火',
    '兩手攀足固腎腰',
    '攢拳怒目增氣力',
    '背後七顛百病消'
  ];

  const modelURL    = './model.json';
  const metadataURL = './metadata.json';

  const verEl = document.getElementById('ver');
  const msgEl = document.getElementById('msg');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const dbg = document.getElementById('debug');
  const $ = id => document.getElementById(id);
  const cssId = n => n.replace(/\s+/g,'-').replace(/[^-\w]/g,'');

  let classifier, labels=[], posenetModel, running=false, flip=true;
  let displayOrder = [];           // 畫條用的實際順序（可能 = DESIRED_EIGHT，或 = metadata.labels）
  let smooth = {};                 // 平滑值表
  let lastTop = '';

  verEl.textContent = `SecureContext=${window.isSecureContext} | tfjs=${(tf&&tf.version&&tf.version.tfjs)||'未載'} | backend=${tf.getBackend()||'-'}`;
  function info(t, ok){ msgEl.className = ok ? 'ok' : (ok===false ? 'bad' : ''); msgEl.textContent = t; }

  $('btnCheck').onclick = async ()=>{
    info('');
    try{
      if(!window.isSecureContext) throw new Error('此頁面不是 HTTPS 或 localhost，瀏覽器會封鎖相機');
      const st = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      st.getTracks().forEach(t=>t.stop());
      info('✅ 相機檢測成功，可以使用', true);
    }catch(e){
      info(`相機自檢失敗：${e.name}\n${e.message||''}\n• NotAllowedError：曾按拒絕或站點權限被關。\n• NotFoundError：沒有可用攝影機。\n• 請用 HTTPS / localhost 並允許相機。`, false);
    }
  };

  $('btnStart').onclick = async ()=>{
    try{
      info('載入中…');
      try{ await tf.setBackend('webgl'); }catch{ await tf.setBackend('cpu'); }
      await tf.ready();

      // 讀 metadata 以取得 labels
      const meta = await fetch(metadataURL,{cache:'no-store'}).then(r=>r.json());
      labels = meta.labels || meta.classes || [];
      if (!Array.isArray(labels) || labels.length === 0) throw new Error('metadata.json 缺少 labels');

      // 載入分類器
      await fetch(modelURL,{cache:'no-store'}).then(r=>{ if(!r.ok) throw new Error(`model.json HTTP ${r.status}`); });
      classifier = await tf.loadLayersModel(modelURL);

      // 載入 PoseNet（TM Pose 常見配置）
      posenetModel = await posenet.load({
        architecture: 'MobileNetV1',
        outputStride: 16,
        inputResolution: { width: 257, height: 257 },
        multiplier: 0.75
      });

      // 建立顯示順序與條
      prepareDisplayOrder();

      // 啟用相機
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'user' }, audio:false });
      video.srcObject = stream;
      await video.play();

      canvas.width = 400; canvas.height = 400;

      info('✅ 模型載入完成，相機啟動成功！', true);
      running = true;
      requestAnimationFrame(loop);
    }catch(e){
      info('❌ 無法載入：\n' + (e.message||e.toString()), false);
      console.error(e);
    }
  };

  // 建立顯示順序（盡量用 DESIRED_EIGHT；若有缺失則 fallback 到 labels）
  function prepareDisplayOrder(){
    const missing = [];
    const present = new Set(labels);
    const order = [];
    DESIRED_EIGHT.forEach(name=>{
      if (present.has(name)) order.push(name);
      else missing.push(name);
    });
    if (missing.length > 0){
      // 有對不到的名稱 → 直接改用 metadata 的真實 labels 顯示，確保條會動
      displayOrder = labels.slice();
      $('labelWarn').innerHTML = `⚠️ <span class="warn">你指定的八式名稱與 metadata.labels 不完全一致：</span><br>
      缺少：<b>${missing.join('、')}</b><br>
      目前已改用 <b>metadata.labels</b> 的順序顯示。`;
    }else{
      displayOrder = order;
      $('labelWarn').textContent = '';
    }
    // 建條
    const bars = $('bars'); bars.innerHTML = '';
    smooth = {};
    displayOrder.forEach(n=>{
      const id = cssId(n);
      smooth[n]=0;
      const row = document.createElement('div');
      row.className = 'bar';
      row.innerHTML = `
        <div class="bar-name" title="${n}">${n}</div>
        <div class="bar-track"><div class="bar-fill" id="fill-${id}" style="width:0%"></div></div>
        <div class="bar-pct" id="pct-${id}">0.00%</div>`;
      bars.appendChild(row);
    });
    // 初始除錯
    dbg.textContent = `labels(from metadata): ${JSON.stringify(labels)}\nusing order: ${JSON.stringify(displayOrder)}`;
  }

  async function loop(){
    if(!running) return;
    await predictOnce();
    requestAnimationFrame(loop);
  }

  // 14739 特徵（heatmap 4913 + offsets 9826）
  function makeFeatures14739(heatmap, offsets){
    const h = heatmap.reshape([17*17*17]);
    const o = offsets.reshape([17*17*34]);
    const concat = tf.concat([h, o]);
    const out = concat.reshape([1, 14739]);
    h.dispose(); o.dispose(); concat.dispose();
    return out;
  }
  // 直接用 baseModel.predict，輸入 3D [257,257,3]
  function posenetPredictRaw(img3d){ return posenetModel.baseModel.predict(img3d); }

  async function predictOnce(){
    // 畫面
    if (flip){ ctx.save(); ctx.scale(-1,1); ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height); ctx.restore(); }
    else { ctx.drawImage(video,0,0,canvas.width,canvas.height); }

    // 估姿勢（畫線用）
    const pose = await posenetModel.estimateSinglePose(video, { flipHorizontal: flip });
    drawKeypoints(pose.keypoints, 0.5, ctx);
    drawSkeleton(pose.keypoints, 0.5, ctx);

    // 取 raw outputs → 14739
    const feat = tf.tidy(()=>{
      let t = tf.browser.fromPixels(video);                // [H,W,3]
      t = tf.image.resizeBilinear(t, [257,257]).toFloat(); // [257,257,3]
      t = t.div(127.5).sub(1);                             // [-1,1]
      const out = posenetPredictRaw(t);                    // batched internally
      const heatmap = out.heatmapScores;                   // [1,17,17,17]
      const offsets = out.offsets;                         // [1,17,17,34]
      const f = makeFeatures14739(heatmap, offsets);       // [1,14739]
      t.dispose();
      return f;
    });

    // 分類
    const pred = classifier.predict(feat);
    const probs = Array.from(await pred.data());
    pred.dispose(); feat.dispose();

    // 映射：用 metadata 的 labels -> 值
    const map = {};
    labels.forEach((name,i)=> map[name] = probs[i] || 0);

    // 依照 displayOrder 更新條
    const alpha=0.35;
    let topName = displayOrder[0] || '', topProb = 0;
    displayOrder.forEach(name=>{
      const p = map[name] ?? 0;
      const val = alpha*p + (1-alpha)*(smooth[name]||0);
      smooth[name] = val;

      const pct = val*100;
      const id = cssId(name);
      const fill = document.getElementById(`fill-${id}`);
      const txt  = document.getElementById(`pct-${id}`);
      if (fill) fill.style.width = `${pct.toFixed(2)}%`;
      if (txt)  txt.textContent  = `${pct.toFixed(2)}%`;

      if (p > topProb){ topProb = p; topName = name; }
    });
    if (!Number.isFinite(topProb)) topProb = 0;
    $('topClass').textContent = `目前辨識：${topName || '—'}（${(topProb*100).toFixed(2)}%）`;

    // 除錯：列出 top-3
    const sorted = labels.map(n=>({n, p: map[n]||0})).sort((a,b)=>b.p-a.p).slice(0,3);
    const changed = (lastTop!==sorted[0]?.n);
    lastTop = sorted[0]?.n || '';
    dbg.textContent =
      `labels(from metadata): ${JSON.stringify(labels)}\n` +
      `using order: ${JSON.stringify(displayOrder)}\n` +
      `top3: ${sorted.map(x=>`${x.n}=${(x.p*100).toFixed(2)}%`).join(' | ')}\n` +
      (changed ? '(top changed)\n' : '');
  }

  /* ====== 畫關鍵點/骨架 ====== */
  function toTuple({y, x}) { return [x, y]; }
  function drawKeypoints(keypoints, minConfidence, ctx) {
    keypoints.forEach(kp=>{
      if (kp.score < minConfidence) return;
      const {y, x} = kp.position;
      ctx.beginPath(); ctx.arc(x, y, 3, 0, 2*Math.PI);
      ctx.fillStyle = 'rgba(16,185,129,0.9)'; ctx.fill();
    });
  }
  const adjacentKeyPoints = [
    [5,7],[7,9],[6,8],[8,10],[5,6],[5,11],[6,12],[11,12],[11,13],[13,15],[12,14],[14,16]
  ];
  function drawSkeleton(keypoints, minConfidence, ctx) {
    adjacentKeyPoints.forEach(([i,j])=>{
      const kp1 = keypoints[i], kp2 = keypoints[j];
      if (kp1.score < minConfidence || kp2.score < minConfidence) return;
      ctx.beginPath();
      const [x1,y1] = toTuple(kp1.position);
      const [x2,y2] = toTuple(kp2.position);
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(59,130,246,0.9)'; ctx.stroke();
    });
  }
})();
</script>
</body>
</html>
