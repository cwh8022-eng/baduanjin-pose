<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>八段錦辨識（本地模型，穩定版）</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;background:#f0f4f8;text-align:center;padding:20px}
    h1{color:#2c3e50}
    #ver{margin:8px 0;color:#555}
    #msg{margin-top:10px;font-weight:700;color:#c0392b;white-space:pre-line}
    button{margin:10px;padding:10px 20px;font-size:16px;border:0;border-radius:6px;background:#2980b9;color:#fff;cursor:pointer}
    canvas{display:block;margin:16px auto;border:2px solid #2c3e50;border-radius:10px}
    #labels div{font-size:16px;margin-top:6px}
  </style>
</head>
<body>
  <h1>八段錦動作辨識（本地模型）</h1>
  <div id="ver">初始化中…</div>
  <button id="btnCheck">① 相機自檢</button>
  <button id="btnStart">② 載入模型並開始</button>
  <div id="msg"></div>
  <canvas id="canvas" width="400" height="400" style="display:none"></canvas>
  <div id="labels"></div>

  <!-- 相容 tmPose 的 tfjs 版本 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.7.4/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>

  <script>
  const verEl = document.getElementById('ver');
  const msgEl = document.getElementById('msg');
  const btnCheck = document.getElementById('btnCheck');
  const btnStart = document.getElementById('btnStart');

  // 顯示環境資訊
  verEl.textContent = `SecureContext=${window.isSecureContext} | tfjs=${(tf&&tf.version&&tf.version.tfjs)||'未載'} | has fromPixels=${typeof tf.fromPixels==='function'}`;

  // === 本地模型路徑（與 index.html 同資料夾）===
  const modelURL    = "./model.json";
  const metadataURL = "./metadata.json";

  let model, webcam, ctx, labels, maxPred;

  btnCheck.onclick = async () => {
    msgEl.textContent = "";
    try {
      if (!window.isSecureContext) {
        throw new Error("此頁面不是 HTTPS 或 localhost，瀏覽器會封鎖相機（SecurityError）");
      }
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      stream.getTracks().forEach(t=>t.stop());
      msgEl.style.color = "#27ae60";
      msgEl.textContent = "✅ 相機檢測成功，可以使用";
    } catch (e) {
      msgEl.style.color = "#c0392b";
      msgEl.textContent = `相機自檢失敗：${e.name}\n${e.message||''}`;
    }
  };

  btnStart.onclick = async () => {
    msgEl.style.color = "#c0392b";
    msgEl.textContent = "載入檢查中…";

    try {
      // 先檢查本地檔是否可取（避免 404/CORS）
      await mustOk(modelURL, "model.json");
      await mustOk(metadataURL, "metadata.json");

      // 檢查 tf 與 fromPixels
      if (typeof tf.fromPixels !== "function") {
        throw new Error("tf.fromPixels 不可用（請確保 tfjs 使用 1.7.4）");
      }

      // backend
      try { await tf.setBackend('webgl'); } catch { await tf.setBackend('cpu'); }
      await tf.ready();

      // 載入模型（本地）
      model = await tmPose.load(modelURL, metadataURL);
      maxPred = model.getTotalClasses();

      // 啟用 Webcam
      const size = 400, flip = true;
      webcam = new tmPose.Webcam(size, size, flip);
      await webcam.setup();
      await webcam.play();
      const canvas = document.getElementById('canvas');
      canvas.style.display = 'block';
      ctx = canvas.getContext('2d');

      // 標籤
      labels = document.getElementById('labels');
      labels.innerHTML = "";
      for (let i = 0; i < maxPred; i++) labels.appendChild(document.createElement("div"));

      msgEl.style.color = "#27ae60";
      msgEl.textContent = "✅ 模型載入完成，相機啟動成功！";
      requestAnimationFrame(loop);

    } catch (e) {
      msgEl.style.color = "#c0392b";
      msgEl.textContent =
        "❌ 無法載入模型：\n" + (e.message || e.toString()) +
        "\n\n請確認以下事項：\n" +
        "• model.json / metadata.json / weights.bin 三檔與 index.html 在同一資料夾。\n" +
        "• 檔名大小寫完全一致（GitHub Pages 大小寫有別）。\n" +
        "• 不是用 file:// 打開，請用 HTTPS 網址或 http://localhost。";
      console.error(e);
    }
  };

  async function mustOk(url, name) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`${name} HTTP ${r.status}（找不到或被阻擋）`);
    // 顯示一下成功
    console.log(`${name} OK`);
    return r;
  }

  async function loop() {
    webcam.update();
    await predict();
    requestAnimationFrame(loop);
  }

  async function predict() {
    const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
    const prediction = await model.predict(posenetOutput);

    ctx.drawImage(webcam.canvas, 0, 0);
    if (pose) {
      tmPose.drawKeypoints(pose.keypoints, 0.5, ctx);
      tmPose.drawSkeleton(pose.keypoints, 0.5, ctx);
    }
    for (let i = 0; i < prediction.length; i++) {
      labels.childNodes[i].textContent =
        `${prediction[i].className}: ${(prediction[i].probability*100).toFixed(2)}%`;
    }
  }
  </script>
</body>
</html>
